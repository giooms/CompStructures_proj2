|; DO NOT EDIT THIS FILE

|; These are 3 helper macros for the canvas_set_to_1 function. You do not need to use those in your code.

|; perform a binary "or" between <Rmem> and Rmask. The resulting values is saved back at the same location (<Rmem>)
.macro MEM_OR(Rmem, Rmask, Rtmp) LD(Rmem, 0, Rtmp) OR(Rtmp, Rmask, Rtmp) ST(Rtmp, 0, Rmem)
|; compute in Rc the address of an element Ridx of an array Raddr
.macro ARRAY_ADDR(Raddr, Ridx, Rc) MULC(Ridx, 4, Rc) ADD(Raddr, Rc, Rc)
|; compute the index of the cell in the Rx-th column and y-th row of the canvas. (note: Rx should be different from Rc)
.macro CANVAS_INDEX(Rx, Ry, Rc) MULC(Ry, bit_per_line, Rc) ADD(Rx, Rc, Rc)


|; This is the canvas_set_to_1 function. You can consider it as a black box (no need to understand its code).

|; canvas_set_to_1(x, y)
|; Set the bit at position (x, y) of the canvas to 1
|; @param x      the x-coordinate of the bit to set to 1 in the canvas.
|; @param y      the y-coordinate of the bit to set to 1 in the canvas.
canvas_set_to_1:

    PUSH(LP) PUSH(BP)
    MOVE(SP, BP)

    PUSH(R1) PUSH(R2) PUSH(R3) PUSH(R4)

    LD(BP, -12, R1) |; x
    LD(BP, -16, R2) |; y

    CMOVE(canvas, R0)

    CMOVE(1, R3)

    CANVAS_INDEX(R1, R2, R2) |; R2 = index of the bit to set to 1 in the canvas

    |; R1 = R0 + (R2 / 32) * 4 (= address of the word containing the bit)
    DIVC(R2, 32, R4) ARRAY_ADDR(R0, R4, R1)
    |; R4 = R2 % 32 (= bit index in the word)
    |; R3 = 1 << R4 (= mask where the bit to set is 1)
    MULC(R4, 32, R4) SUB(R2, R4, R4) SHL(R3, R4, R3)

    MEM_OR(R1, R3, R4) |; set the bit to 1

    POP(R4) POP(R3) POP(R2) POP(R1)

    POP(BP) POP(LP)

    RTN()
